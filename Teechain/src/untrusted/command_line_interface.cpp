#include <string>
#include <vector>
#include <unistd.h>
#include <sys/time.h>

#include "command_line_interface.h"
#include "network.h"
#include "utils.h"
#include "teechain.h"

// Globals for command line interface:

// hostname and port of local teechain node for the command line to connect to. 
static std::string hostname(DEFAULT_HOSTNAME);
static int port = DEFAULT_PORT;

// remote hostname and port for the teechain node to connect to. 
static std::string remote_host(DEFAULT_HOSTNAME);
static int remote_port = 0;

// optional flags to define teechain node properties.
static bool initiator = false;
static bool use_monotonic_counters = false;
bool debug = false;
bool benchmark = false;

// sockfd holding the connection to the local teechain node (once connected).
static int local_sockfd = -1;

static bool enough_arguments_for_command(int expected_num_args, int argc) {
    return argc > optind + expected_num_args;
}

static void validate_channel_id(std::string channel_id) {
    if (channel_id.length() != CHANNEL_ID_LEN) {
        printf("Given channel id: %s", channel_id.c_str());
        error("Channel id length incorrect");
    }
}

static void validate_transaction(std::string transaction) {
    if (transaction.length() > MAX_BITCOIN_TX_LEN) {
        error("Given transaction has length greater than MAX_BITCOIN_TX_LEN");
    }
}

static void validate_amount_to_send(unsigned long long amount) {
    if (amount <= 0) {
        error("Can only send positive amount!");
    }
}

static bool is_valid_hostname(std::string hostname) {
    return hostname.length() <= REMOTE_HOST_LEN;
}

bool is_valid_port(int port) {
    return port >= 0 && port <= 65535;
}

static void usage(void) {
    std::cerr << ("Usage: teechain [command] [options]\n") << std::endl;
    std::cerr << ("Teechain commands: \n"
        "ghost:          Creates a Teechain enclave (not yet a primary or backup). \n"
        "primary:        Assigns an existing ghost to become a primary node. \n"
        "                  Contacts localhost at port p to make assignment. \n"
        "backup:         Assigns an existing ghost to become a backup node. \n"
        "                  Contacts localhost at given port to make assignment. \n"
        "add_backup:     Adds a backup node to a Teechain backup chain. \n"
        "                  Chain length must be >= 1, with head being a primary node. \n"
        "                  Must notify the tail of the chain, and the new backup node (in this order). \n"
        "remove_backup:  Removes a backup node from a Teechain backup chain. \n"
        "                  Only the tail of the chain can be removed. \n"
        "                  Only the tail of the chain needs to be notified (it will contact the next node). \n"
        "setup_deposits: Gives a primary node the information about the number of deposits the user wishes to make. \n"
        "                  The TEE then returns a set of bitcoin addresses the user should pay into. \n"
        "deposits_made:   Gives the primary node the transaction hash of the transaction that was generated by \n"
        "                  the ownwer and paid the deposits into the primary node's bitcoin account. This requires \n"
        "                  knowing the redeem scripts to spend and the account to return funds to on settlement.\n"
        "                  This is the information presented to counter party, requiring manual verification. \n"
        "add_deposit:    Assigns an unused (but verified) deposit to a channel. When adding a deposit to a channel \n"
        "                  the adding TEE adds the funds before requiring an ack from the remote party. This is \n"
        "                  an optimization, but doesn't break safety. \n"
        "remove_deposit: Removes an assigned (but unspent) deposit from a channel. The removing TEE *must wait* \n"
        "                  for the remote TEE to ack the removal first, before removing. This is to ensure \n"
        "                  we don't break safety. \n"
        "create_channel: Creates a channel with a remote party. \n"
        "                  Both sides of the channel must have create called. \n"
        "                  The initiating side will start the message exchange process. \n"
        "                  The add_backup command uses the same message exchange protocol as here. \n"
        "verify_deposits: The manual verification step that must be performed by the user to verify that the \n"
        "                  deposit transactions presented by the remote TEE do actually exist and are actually \n"
        "                  in the blockchain. \n"
        "                  This is called on an individual channel after creation, but before sending can occur. \n"
        "                  We don't yet wait for a secure ack from the remote party (i.e. for them to establish \n"
        "                  the channel on their side -- but this is fine). \n"
        "send:           Sends a payment across a channel to the counterparty. \n"
        "settle_channel: Generate a transaction that closes a single channel and notifies the counterparty. \n"
        "                  This can only be called on the primary node. \n"
        "return_unused_deposits: Generate a transaction that returns the currently unused deposits. \n"
        "shutdown:       Settle each of the channels individually. Also generate a transaction that returns \n"
        "                  unused deposits back to the owner. \n")  << std::endl;
    exit(1);
}

static void wait_for_send_ack(int sockfd) {
    char response[MAX_ECALL_SEND_RETURN_LENGTH];
    read_from_socket(sockfd, response, MAX_ECALL_SEND_RETURN_LENGTH);

    if (response[MSG_LEN_BYTES] == OP_LOCAL_ACK) {
        if (!benchmark) {
            printf("Your payment has been sent!\n");
        }
    } else {
        std::string message = "Send error: " + response[MSG_LEN_BYTES];
        error(message);
    }
}

static void local_send_async(unsigned long long amount, std::string channel_id) {
    struct LocalSendMsg msg;
    msg.msg_op[0] = OP_LOCAL_SEND;
    msg.amount = amount;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    send_on_socket((char*) &msg, sizeof(struct LocalSendMsg), local_sockfd); 
}

static void local_send(int argc, char* argv[]) {
    if (!enough_arguments_for_command(2, argc)) usage();

    std::string channel_id(argv[optind + 1]);
    unsigned long long amount = strtoull(argv[optind + 2], NULL, 10);
    validate_channel_id(channel_id);    
    validate_amount_to_send(amount);

    local_send_async(amount, channel_id);
    wait_for_send_ack(local_sockfd);
    close(local_sockfd);
}

static void local_benchmark(int argc, char* argv[]) {
    if (!enough_arguments_for_command(2, argc)) usage();

    std::string channel_id(argv[optind + 1]);
    unsigned long long number_of_sends = strtoull(argv[optind + 2], NULL, 10); // number of sends to perform

    validate_channel_id(channel_id);
    unsigned long amount = 1;

    // force benchmark on
    benchmark = true;

    struct timeval start;
    struct timeval end;

    // begin benchmarking
    gettimeofday(&start, NULL);    
    for (int i = 0; i < number_of_sends; i++) {
        local_send_async(amount, channel_id);
    }
    for (int i = 0; i < number_of_sends; i++) {
        wait_for_send_ack(local_sockfd);
    }
    gettimeofday(&end, NULL);
    // end benchmarking

    float num_milliseconds_in_sec = 1000000.0;
    float elapsed_time = (float(end.tv_sec - start.tv_sec) * num_milliseconds_in_sec) + (float(end.tv_usec - start.tv_usec));
    //std::cout << "Total time elapsed for " << number_of_sends << " send operations: " << elapsed_time << std::endl;

    float txs = (number_of_sends / elapsed_time) * num_milliseconds_in_sec;
    std::string message = "Transactions per second: " + std::to_string(txs);
    print_important(message.c_str());

    close(local_sockfd);
}

static void local_wait_for_response_and_close(int sockfd, const char* msg) {
    char response[MAX_MESSAGE_RESPONSE_LENGTH];
    read_from_socket(sockfd, response, MAX_MESSAGE_RESPONSE_LENGTH);
    close(sockfd);
    log_debug(msg);
    printf("%s\n", &response[MSG_LEN_BYTES]);
}

// issues a command to the local teechain enclave for a specific channel
static void local_issue_command_for_channel(int sockfd, unsigned int command, std::string channel_id) {
    struct LocalGenericMsg msg;

    msg.msg_op[0] = command;
    memcpy((char *) msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);

    send_on_socket((char*) &msg, sizeof(struct LocalGenericMsg), sockfd); 
}

// issues a command to the local teechain enclave
static void local_issue_command(int sockfd, unsigned int command) {
    struct LocalGenericMsg msg;
    msg.msg_op[0] = command;
    send_on_socket((char*) &msg, sizeof(struct LocalGenericMsg), sockfd); 
}

static void local_settle_channel(int argc, char* argv[]) {
    if (!enough_arguments_for_command(1, argc)) usage();

    std::string channel_id(argv[optind + 1]);
    validate_channel_id(channel_id);    

    local_issue_command_for_channel(local_sockfd, OP_LOCAL_SETTLE, channel_id);
    local_wait_for_response_and_close(local_sockfd, "local_settle");
}

static void local_present_settlement(int argc, char* argv[]) {
    if (!enough_arguments_for_command(2, argc)) usage();

    std::string channel_id(argv[optind + 1]);
    validate_channel_id(channel_id);
    std::string settlement_transaction(argv[optind + 2]);
    validate_transaction(settlement_transaction);

    // construct present_settlement message with data
    struct LocalPresentSettlementMsg msg;
    msg.msg_op[0] = OP_LOCAL_PRESENT_SETTLEMENT;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    memcpy(msg.settlement_transaction, settlement_transaction.c_str(), settlement_transaction.length());
    msg.settlement_transaction_len = settlement_transaction.length();

    std::cout << "Sending settlement present" << std::flush;
    // send local message
    send_on_socket((char*) &msg, sizeof(struct LocalPresentSettlementMsg), local_sockfd);
    std::cout << "Sent settlement present" << std::flush;
    local_wait_for_response_and_close(local_sockfd, "local_present_settlement");
    std::cout << "Finished waiting on sockfd" << std::flush;
}

static void local_return_unused_deposits(int argc, char* argv[]) {
    if (!enough_arguments_for_command(0, argc)) usage();
    local_issue_command(local_sockfd, OP_LOCAL_RETURN_UNUSED);
    local_wait_for_response_and_close(local_sockfd, "local_return_unused");
}

static void local_shutdown(int argc, char* argv[]) {
    if (!enough_arguments_for_command(0, argc)) usage();
    local_issue_command(local_sockfd, OP_LOCAL_SHUTDOWN);
    local_wait_for_response_and_close(local_sockfd, "local_shutdown");
}

static void local_primary(int argc, char* argv[]) {
    struct LocalAssignmentMsg msg;
    msg.msg_op[0] = OP_LOCAL_PRIMARY;
    msg.use_monotonic_counters = use_monotonic_counters;
    send_on_socket((char*) &msg, sizeof(struct LocalAssignmentMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_primary");
}

static void local_backup(int argc, char* argv[]) {
    struct LocalAssignmentMsg msg;
    msg.msg_op[0] = OP_LOCAL_BACKUP;
    send_on_socket((char*) &msg, sizeof(struct LocalAssignmentMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_backup");
}

static void local_remove_backup(int argc, char* argv[]) {
    if (!enough_arguments_for_command(1, argc)) usage();

    // check arguments
    std::string backup_channel_id(argv[optind + 1]);
    validate_channel_id(backup_channel_id);

    // construct remove message with data
    struct LocalRemoveBackupMsg msg;
    msg.msg_op[0] = OP_LOCAL_REMOVE_BACKUP;
    memcpy(msg.backup_channel_id, backup_channel_id.c_str(), CHANNEL_ID_LEN);

    // send remove message
    send_on_socket((char*) &msg, sizeof(struct LocalRemoveBackupMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_remove_backup");
}

static void local_add_backup(int argc, char* argv[]) {
    if (!enough_arguments_for_command(0, argc)) usage();

    // assign the channel a temporary channel id
    std::string channel_id(TEMPORARY_CHANNEL_ID, CHANNEL_ID_LEN);
    validate_channel_id(channel_id);

    // construct create message with data
    struct LocalCreateBackupMsg msg;
    msg.msg_op[0] = OP_LOCAL_ADD_BACKUP;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    msg.initiator = initiator;
    if (initiator) {
        memcpy(msg.remote_host, remote_host.c_str(), remote_host.length());
        msg.remote_host_len = remote_host.length();
        msg.remote_port = remote_port;
    }

    // send create message
    send_on_socket((char*) &msg, sizeof(struct LocalCreateBackupMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_add_backup");
}

static void local_balance(int argc, char* argv[]) {
    if (!enough_arguments_for_command(1, argc)) usage();

    std::string channel_id(argv[optind + 1]);
    validate_channel_id(channel_id);    

    local_issue_command_for_channel(local_sockfd, OP_LOCAL_BALANCE, channel_id);
    local_wait_for_response_and_close(local_sockfd, "local_balance");
}

static void local_verify_deposits(int argc, char* argv[]) {
    if (!enough_arguments_for_command(1, argc)) usage();

    std::string channel_id(argv[optind + 1]);
    validate_channel_id(channel_id);    

    local_issue_command_for_channel(local_sockfd, OP_LOCAL_VERIFY_DEPOSITS, channel_id);
    local_wait_for_response_and_close(local_sockfd, "local_verify_deposits");
}

static void local_add_deposit(int argc, char* argv[]) {
    if (!enough_arguments_for_command(2, argc)) usage();

    // parse channel ID and deposit index
    std::string channel_id(argv[optind + 1]);
    unsigned long long deposit_id = strtoull(argv[optind + 2], NULL, 10); // deposit index to add to channel
    validate_channel_id(channel_id);    

    // construct setup message with data
    struct LocalDepositMsg msg;
    msg.msg_op[0] = OP_LOCAL_TEECHAIN_DEPOSIT_ADD;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    msg.deposit_id = deposit_id;

    // send local message
    send_on_socket((char*) &msg, sizeof(struct LocalDepositMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_add_deposit");
}

static void local_remove_deposit(int argc, char* argv[]) {
    if (!enough_arguments_for_command(2, argc)) usage();

    // parse channel ID and deposit index
    std::string channel_id(argv[optind + 1]);
    unsigned long long deposit_id = strtoull(argv[optind + 2], NULL, 10); // deposit index to add to channel
    validate_channel_id(channel_id);    
    
    // construct deposit message with data
    struct LocalDepositMsg msg;
    msg.msg_op[0] = OP_LOCAL_TEECHAIN_DEPOSIT_REMOVE;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    msg.deposit_id = deposit_id;

    // send deposit message
    send_on_socket((char*) &msg, sizeof(struct LocalDepositMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_remove_deposit");
}

static void local_setup_deposits(int argc, char* argv[]) {
    if (!enough_arguments_for_command(1, argc)) usage();

    unsigned long long num_deposits = strtoull(argv[optind + 1], NULL, 10); // number of deposits

    // construct setup deposit message with data
    struct LocalSetupDepositsMsg msg = {}; // zero initialize the struct
    msg.msg_op[0] = OP_LOCAL_TEECHAIN_SETUP_DEPOSITS;
    msg.num_deposits = num_deposits;

    // send setup message
    send_on_socket((char*) &msg, sizeof(struct LocalSetupDepositsMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_setup_deposit");
}

static void local_deposits_made(int argc, char* argv[]) {
    if (!enough_arguments_for_command(6, argc)) usage();
    
    std::string my_address(argv[optind + 1]); // my bitcoin address in B58 format to return funds to
    unsigned long long miner_fee_to_pay = strtoull(argv[optind + 2], NULL, 10); // miner fee I want to pay
    unsigned long long num_deposits = strtoull(argv[optind + 3], NULL, 10); // number of deposits

    // extract deposits one at a time
    std::map<unsigned long long, std::string> depositIdToTxid;
    std::map<unsigned long long, unsigned long long> depositIdToTxIndex;
    std::map<unsigned long long, unsigned long long> depositIdToAmount;
    unsigned int first_deposit_pointer = optind + 4;
    for (unsigned int i = first_deposit_pointer; i < first_deposit_pointer + (num_deposits * 3); i += 3) {
        std::string txid(argv[i]);
        unsigned long long tx_index = strtoull(argv[i + 1], NULL, 10); // tx index funding enclave for this deposit
        unsigned long long deposit_amount = strtoull(argv[i + 2], NULL, 10); // deposit amount for this deposit
        int deposit_id = (i - first_deposit_pointer) / 3;

        // store deposit into maps
        depositIdToTxid[deposit_id] = txid;
        depositIdToTxIndex[deposit_id] = tx_index;
        depositIdToAmount[deposit_id] = deposit_amount;
    }

    // construct deposits made message with data
    struct LocalDepositsMadeMsg msg = {}; // zero initialize the struct
    msg.msg_op[0] = OP_LOCAL_TEECHAIN_DEPOSITS_MADE;
    memcpy(msg.my_address, my_address.c_str(), BITCOIN_ADDRESS_LEN);
    msg.miner_fee = miner_fee_to_pay;
    msg.num_deposits = num_deposits;

    // fill deposits and scripts
    for (unsigned int i = 0; i < num_deposits; i++) {
        std::string txid = depositIdToTxid[i];
        unsigned long long tx_index = depositIdToTxIndex[i];
        unsigned long long deposit_amount = depositIdToAmount[i];

        struct LocalDepositMadeMsg deposit = msg.deposits[i];
        memcpy(deposit.txid, txid.c_str(), BITCOIN_TX_HASH_LEN);
        deposit.tx_index = tx_index;
        deposit.deposit_amount = deposit_amount;

        int deposit_made_length = sizeof(struct LocalDepositMadeMsg);
        char *deposit_location = (char *) msg.deposits + (i * deposit_made_length);
        memcpy((void *) deposit_location, (void*) &deposit, deposit_made_length);
    }

    // send setup message
    send_on_socket((char*) &msg, sizeof(struct LocalDepositsMadeMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_deposits_made");
}

static void local_setup(int argc, char* argv[]) {
    if (!enough_arguments_for_command(9, argc)) usage();

    std::string my_address(argv[optind + 1]); // my bitcoin address in B58 format
    std::string setup_public_key(argv[optind + 2]); // my bitcoin public key
    std::string setup_private_key(argv[optind + 3]); // my bitcoin private key
    std::string setup_utxo_hash(argv[optind + 4]); // utxo hash to deposit into setup
    unsigned long long setup_utxo_index = strtoull(argv[optind + 5], NULL, 10); // utxo index
    std::string setup_utxo_script(argv[optind + 6]); // utxo script
    unsigned long long num_deposits = strtoull(argv[optind + 7], NULL, 10); // number of deposits
    std::map<unsigned long long, unsigned long long> depositIndexToAmounts;
    unsigned int first_deposit_pointer = optind + 8;
    for (unsigned int i = first_deposit_pointer; i < first_deposit_pointer + num_deposits; i++) {
        unsigned long long deposit_amount = strtoull(argv[i], NULL, 10); // deposit amount in satoshi
        depositIndexToAmounts[i - first_deposit_pointer] = deposit_amount;
    }

    // construct setup message with data
    struct LocalSetupMsg msg = {}; // zero initialize the struct
    msg.msg_op[0] = OP_LOCAL_TEECHAIN_SETUP;
    memcpy(msg.my_address, my_address.c_str(), BITCOIN_ADDRESS_LEN);
    memcpy(msg.setup_public_key, setup_public_key.c_str(), BITCOIN_PUBLIC_KEY_LEN);
    memcpy(msg.setup_private_key, setup_private_key.c_str(), BITCOIN_PRIVATE_KEY_LEN);
    memcpy(msg.setup_utxo_hash, setup_utxo_hash.c_str(), BITCOIN_TX_HASH_LEN);
    msg.setup_utxo_index = setup_utxo_index;
    memcpy(msg.setup_utxo_script, setup_utxo_script.c_str(), setup_utxo_script.length());

    // fill deposits
    msg.num_deposits = num_deposits;
    for (unsigned int i = 0; i < num_deposits; i++) {
        unsigned long long deposit_amount = depositIndexToAmounts[i];
        msg.deposit_amounts[i] = deposit_amount;
    }

    // send setup message
    send_on_socket((char*) &msg, sizeof(struct LocalSetupMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_setup");
}

static void local_txid_setup(int argc, char* argv[]) {
    if (!enough_arguments_for_command(1, argc)) usage();

    std::string transaction_hash(argv[optind + 1]);

    // construct setup transaction hash message with data
    struct LocalSetupTxidMsg msg;
    msg.msg_op[0] = OP_LOCAL_TEECHAIN_SETUP_TXID;
    memcpy(msg.setup_hash, transaction_hash.c_str(), BITCOIN_TX_HASH_LEN);

    // send setup message
    send_on_socket((char*) &msg, sizeof(struct LocalSetupTxidMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_txid_setup");
}

static void local_create_channel(int argc, char* argv[]) {
    if (!enough_arguments_for_command(0, argc)) usage();

    // assign the channel a temporary channel id
    std::string channel_id(TEMPORARY_CHANNEL_ID, CHANNEL_ID_LEN);
    validate_channel_id(channel_id);

    // construct create message with data
    struct LocalCreateMsg msg;
    msg.msg_op[0] = OP_LOCAL_CREATE;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    msg.initiator = initiator;
    if (initiator) {
        memcpy(msg.remote_host, remote_host.c_str(), remote_host.length());
        msg.remote_host_len = remote_host.length();
        msg.remote_port = remote_port;
    }

    // send setup message
    send_on_socket((char*) &msg, sizeof(struct LocalCreateMsg), local_sockfd);
    local_wait_for_response_and_close(local_sockfd, "local_create_channel");
}

static void validate_and_execute_command(int argc, char* argv[]) {
    if (optind == argc) {
        usage(); // no command given
    }

    char* command = argv[optind];
    if (streq(command, "ghost")) {
        ghost(port); // this process is now a teechain ghost node
        return;
    }

    // connect to already running teechain node and issue local command
    local_sockfd = connect_to_socket(hostname, port);  

    // for benchmarking purposes we time the various operations
    struct timeval start;
    struct timeval end;

    // begin timing operation
    gettimeofday(&start, NULL);

    if (streq(command, "primary")) {
        local_primary(argc, argv);

    } else if (streq(command, "backup")) {
        local_backup(argc, argv);

    } else if (streq(command, "add_backup")) {
        local_add_backup(argc, argv);

    } else if (streq(command, "remove_backup")) {
        local_remove_backup(argc, argv);

    } else if (streq(command, "setup_deposits")) {
        local_setup_deposits(argc, argv);

    } else if (streq(command, "deposits_made")) {
        local_deposits_made(argc, argv);

    } else if (streq(command, "add_deposit")) {
        local_add_deposit(argc, argv);

    } else if (streq(command, "remove_deposit")) {
        local_remove_deposit(argc, argv);

    } else if (streq(command, "create_channel")) {
        local_create_channel(argc, argv);

    } else if (streq(command, "send")) {
        local_send(argc, argv);

    } else if (streq(command, "verify_deposits")) {
        local_verify_deposits(argc, argv);

    } else if (streq(command, "shutdown")) {
        local_shutdown(argc, argv);

    } else if (streq(command, "return_unused")) {
        local_return_unused_deposits(argc, argv);

    } else if (streq(command, "settle_channel")) {
        local_settle_channel(argc, argv);

    } else if (streq(command, "present_settlement")) {
        local_present_settlement(argc, argv);

    } else if (streq(command, "benchmark")) {
        local_benchmark(argc, argv);

    } else if (streq(command, "balance")) {
        local_balance(argc, argv);
    }
    
    // finish timing operation
    gettimeofday(&end, NULL);
    float num_milliseconds_in_sec = 1000000.0;
    double elapsed_time = ((float(end.tv_sec - start.tv_sec) * num_milliseconds_in_sec) + (float(end.tv_usec - start.tv_usec))) / num_milliseconds_in_sec;
    std::string message = "Total time elapsed to perform operation " + std::string(command) +  ": " + std::to_string(elapsed_time) +  " (sec)";
    log_debug(message.c_str());
}

// Validates all options after they have already been parsed
static void validate_command_options() {
    if (!is_valid_hostname(hostname)) {
        error("Invalid hostname given!");
    }

    if (!is_valid_port(port)) {
        error("Invalid port given!");
    }

    if (!is_valid_hostname(remote_host)) {
        error("Invalid remote hostname given!");
    }

    if (!is_valid_port(remote_port)) {
        error("Invalid remote port given!");
    }
}

int main(int argc, char* argv[]) {
    // Parse command line options
    int opt_ret;
    while ((opt_ret = getopt(argc, argv, "h:p:mdbir:")) != -1) {
        switch (opt_ret) {
            case 'h':
                hostname = std::string(optarg);
                break;
            case 'p':
                port = atoi(optarg);
                break;
            case 'm':
                use_monotonic_counters = true;
                break;
            case 'd':
                debug = true;
                break;
            case 'b':
                benchmark = true;
                break;
            case 'i':
                initiator = true;
                break;
            case 'r': {
                char* host_and_port= optarg;
                char *token;
                const char *colon = ":";
                token = strtok(host_and_port, colon);
                remote_host = std::string(token);
                token = strtok(NULL, colon);
                remote_port = atoi(token);
                break;
            }
            default:
                usage();
        }
    }
    validate_command_options();
    validate_and_execute_command(argc, argv);
    return 0;
}
